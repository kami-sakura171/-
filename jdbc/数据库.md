# 数据库

## 1.基础部分

 由来：龟壳-》文件-》网状-》关系数据库-》非关系型数据库

数据库：数据结构+算法



1.行、列的关系；

2.表与表的关系：1:1 ,1:N，N:N

3.单表：字段、主键(复合主键)、索引(解决查询性能)

4.冗余(高并发场景，解决表与表之间过多的关联查询影响性能)

**5.不能用关键字作为列名**



备份：

1：小项目：基于客户端工具在使用；

2：大项目：基于数据命令在备份；mysqldump



## 2.增删改查



1.**DDL**：创建数据库和表的结构

2.**DML**：来操作数据库表中的记录（数据）



1.数据库建立：UTF-8字符集(解决中文乱码的问题)

   Creat  alter   drop

2.数据表

| **名称**  | **类型**       | **说明**                                                     |
| --------- | -------------- | ------------------------------------------------------------ |
| int       | 整数           |                                                              |
| double    | 浮点数         |                                                              |
| decimal   | 定位精度小数   | 例如：decimal(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99。 |
| char      | 固定长度字符串 | 例如：char(10)的数据'aaa    '中只有三个有效字符，但总共占10个字符长，后面七个是空格。一般不用。 |
| varchar   | 可变长度字符串 | 例如：varchar(10)的数据'aaa'中只有3个字符，没有多余的空格。它最多可以有10个字符。这是最常用类型。 |
| date      | 日期           | 格式为：yyyy-MM-dd。只有日期数据。                           |
| time      | 时间           | 格式为：hh:mm:ss。只有时间数据。                             |
| timestamp | 时间戳         | 格式为：yyyy-MM-dd hh:mm:ss。使用这个类型时，写入记录会自动被赋值为当前时间。一般不用。 |
| datetime  | 日期时间       | 格式为：yyyy-MM-dd hh:mm:ss。表示日期和时间。最常用。        |
| text      | 大字符串       | 保存大数据量的字符，<4M。一般不用。                          |
| blob      | 二进制大对象   | 可以存储二进制文件的容器，如文件、图片。一般不用。           |



**大的文本和大数据，觉对不能存储在关系型数据库中。**

NOSQL、直接就文件；



## 约束性：

1.主键

2.唯一性约束

3.非空约束

4.外键约束



**总结：保证数据的干净、完整性。数据库加约束。在实际生产环境中(大并发、数据大)，是不能把所有的业务需求条件让数据库完成。最终导致数据库性能低下、死锁。一般是在前端、应用端(程序)进行逻辑判断，最终单纯入库。**



数据库里面的一些概念：

**视图：虚表。目的：解决多张表之间关联查询的复杂性，方便其他人调用。**

**触发器：目的：更新主表的时候，顺带要更新其他逻辑。实际生产环境很少用触发器。**

**过程体：函数:  自定义函数，数据库自带函数。sum, avg**

**存储过程：将业务逻辑采用数据库支持的语法进行实现。**



## 3.insert

1.多行插入：INSERT INTO employee(name,job,manager,hiredate,salary,bonus,deptid)

​         VALUES  行一, 行二,.........

**2.子查询插入:INSERT INTO backup_employee (name,job,manager,hiredate,salary,bonus,deptid)** 

​     **(SELECT name,job,manager,hiredate,salary,bonus,deptid FROM employee );**



## 4.UPDATE

1.语法：UPDATE 表名 SET 列名1=列值1，列名2=列值2 ... WHERE 列名=值



## 5.DELETE

1.语法：DELETE 表名 [WHERE 列名=值]

 2.外键约束关系： 主从关系，先删除从表记录，再删主表记录

3.delete  与truncate table 区别： delete只删除记录， truncate删除表，再重新建表，全表删除是最彻底的；



## 6.SELECT

1.语法：SELECT 列名 FROM 表名

​     [WHERE  GROUP BY  HAVING  ORDER BY]

2.指定列查询，不能用*代替；

3.运算符：

| =、!=、<>、<、<=、>、>= | 比较运算符，注意 = 是等于，<> 是不等于   |
| ----------------------- | ---------------------------------------- |
| BETWEEN…AND             | 值区间测试                               |
| [NOT] IN(set)           | 判断值是否在某个集合（子查询）范围中     |
| [NOT] EXISTS(set)       | 判断值是否在某个集合（子查询）范围中存在 |
| IS NULL                 | 是否为NULL                               |
| AND                     | 与                                       |
| OR                      | 或                                       |
| NOT                     | 非                                       |

 注意：IN  效率低下；

**4.LIKE**

  %%

5.去重

​	SELECT DISTINCT 字段  FROM 表;

6.别名

7.排序

order by

8.聚合函数

 COUNT()、MAX()、MIN()、SUM()、AVG()

 9.分组

 注意：having与where的区别：

**having是在分组后对数据进行过滤，where是在分组前对数据进行过滤。**

**having可以使用分组函数(统计函数)，where不可以使用分组函数。**

**WHERE是对分组前记录的过滤条件，如果某行记录没有满足WHERE子句要求，那么这行记录不会参加分组；而HAVING是对分组后数据的过滤条件。**



分页查询：

查询语句书写顺序：select – from - where - group by - having - order by - limit

查询语句执行顺序：from - where - group by - having - select - order by - limit



10.子查询：



## 问题回顾：

1.最后项目不分组，每个人跟着老师把一个小项目一起敲一遍；

2.每个人都要最后提交自己的实训成果、实训报告；





