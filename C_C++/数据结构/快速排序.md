### 快速排序

快速排序是一种划分交换排序。它采用了一种分治的策略，通常称其为分治法（ Divide-and
ConquerMethod）。
（ 1）分治法的基本思想，将原问题分解为若干个规模更小但结构与原问题相似的子问题。递
归地解这些子问题，然后将这些子问题的解组合为原问题的解。
（ 2）快速排序的基本思想
设当前待排序的无序区为 R[low..high]，利用分治法的基本思想如下。
① 分解。 在 R[low..high]中任选一个记录作为基准（ Pivot）， 以此基准将当前无序区划分为左、
右两个较小的子区间 R[low..pivotpos-1]和 R[pivotpos+1..high]，并使左边子区间中所有记录的关键
字均小于等于基准记录（不妨记为 pivot）的关键字 pivot.key，右边的子区间中所有记录的关键字
均大于等于 pivot.key，而基准记录 pivot 则位于正确的位置（ pivotpos）上，无需参加后续的排序。
划分的关键是要求出基准记录所在的位置 pivotpos。划分的结果可以简单地表示为（注意
pivot=R[pivotpos]): R[low..pivotpos-1].keys≤R[pivotpos].key≤R[pivotpos+1..high].keys，其中 low≤pivotpos≤high。
② 求解。通过递归调用快速排序对左、右子区间 R[low..pivotpos-1]和 R[pivotpos+1..high]快
速排序。
③ 组合。因为当“求解”步骤中的两个递归调用结束时，其左、右两个子区间已有序。对快
速排序而言， “组合”步骤无需做什么，可看作是空操作。  

#### 基本思想：

1.选定pivot中心轴

2.将大于pivot的数字放在pivot的右边

3.将小于pivot的数字放在pivot的左边

4，分别对pivot左右子序列重复前三步操作

注：中心轴pivot是不需要移动的



完整代码：

```c
#include <stdio.h>
#define MAX 255
int R[MAX];

int Partition(int i, int j)
{  //调用partition(R,low,high)时，对数组R[low..high]做划分，并返回基准元素的位置
    int pivot = R[i]; //用区间的第i个元素作为基准
    while (i < j)
    {  //从区间两端交替向中间扫描，直至i = j为止
        while (i < j && R[j] >= pivot) //pivot相当于在位置i上
            j--;   //从右向左扫描，查找第一个小于pivot的元素R[j]
        if (i < j)  //找到的R[j]小于pivot
            R[i++] = R[j];  //交换R[i]和R[j],交换后i指针加一
        while (i < j && R[i] <= pivot) //pivot相当于在位置j上
            i++;  //从左向右扫描，查找第一个大于pivot的元素R[i]
        if (i < j)  //找到的R[i]大于pivot
            R[j--] = R[i];  //交换R[i]和R[j],交换后j指针减一
    }
    R[i] = pivot; //基准元素被最后定位
    return i;
}

void Quick_Sort(int low, int high)
{  //对R[low..high]进行快速排序
    int picvotpos; //划分后基准元素的位置
    if (low < high)
    {   //区间长度大于一，进行排序
        picvotpos = Partition(low, high); //对R[low..high]做划分
        Quick_Sort(low, picvotpos - 1);   //对左区间递归排序
        Quick_Sort(picvotpos + 1, high);  //对右区间递归排序
    }
}

int main()
{
    int i, n;
    puts("输入要输入的元素的个数：");
    scanf("%d", &n);
    if (n <= 0 || n > MAX)
    {
        printf("n 必须大于0 并且小于 %d.\n", MAX);
        exit(0);
    }
    puts("输入元素：");
    for (i = 1; i <= n; i++)
        scanf("%d", &R[i]);
    puts("\n你输入的数组为：");
    for (i = 1; i <= n; i++)
        printf("%4d", R[i]);
    Quick_Sort(1, n);
    puts("\n经过快速排序后为:");
    for (i = 1; i <= n; i++)
        printf("%4d", R[i]);
    puts("\n 按任意键退出...");
    getch();
}
```

