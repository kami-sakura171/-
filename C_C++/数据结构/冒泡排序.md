### 冒泡排序

将被排序的记录数组 R[1..n]垂直排列，每个记录 R[i]看做是重量为 R[i].key 的气泡。根据轻
气泡不能在重气泡之下的原则，从下往上扫描数组 R。凡扫描到违反本原则的轻气泡，就使其向
上“飘浮”。如此反复进行，直到最后任何两个气泡都是轻者在上，重者在下为止。
（ 1）初始， R[1..n]为无序区。
（ 2）第一趟扫描，从无序区底部向上依次比较相邻的两个气泡的重量，若发现轻者在下、重
者在上，则交换二者的位置。即依次比较(R[n]， R[n-1])， (R[n-1]， R[n-2])，…， (R[2]， R[1])；
对于每对气泡(R[j+1]， R[j])，若 R[j+1].key<R[j].key，则交换 R[j+1]和 R[j]的内容。
第一趟扫描完毕时， “最轻”的气泡就飘浮到该区间的顶部， 即关键字最小的记录被放在最高
位置 R[1]上。
（ 3）第二趟扫描，扫描 R[2..n]。扫描完毕时， “次轻”的气泡飘浮到 R[2]的位置上……最后，
经过 n-1 趟扫描可得到有序区 R[1..n]
注意：第 i 趟扫描时， R[1..i-1]和 R[i..n]分别为当前的有序区和无序区。扫描仍是从无序区底
部向上直至该区顶部。扫描完毕时，该区中最轻气泡飘浮到顶部位置 R[i]上，结果是 R[1..i]变为
新的有序区。  

#### 冒泡排序算法

因为每一趟排序都使有序区增加了一个气泡，在经过 n-1 趟排序之后，有序区中就有 n-1 个
气泡，而无序区中气泡的重量总是大于等于有序区中气泡的重量，所以整个冒泡排序过程至多需
要进行 n-1 趟排序。
若在某一趟排序中未发现气泡位置的交换， 则说明待排序的无序区中所有气泡均满足轻者在上，
重者在下的原则，因此，冒泡排序过程可在此趟排序后终止。为此，在下面给出的算法中，引入一
个布尔量 exchange，在每趟排序开始前，先将其置为 FALSE。若排序过程中发生了交换，则将其置
为 TRUE。各趟排序结束时检查 exchange，若未曾发生过交换则终止算法，不再进行下一趟排序。  

#### 具体算法：

```c
void Bubble_Sort(int n)
{
    /*R(1..n)是待排序的元素，采用自下向上扫描，对R做冒泡排序*/
    int i, j;
    int exchange; //交换标志
    for (i = 0; i < n; i++)
    {
        exchange = 0; //本趟排序开始，交换标志为假
        for (j = n - 1; j >= i; j--)
        { //对当前无序区R[i..n]自后向上前扫描，并将这之中最小的元素交换到有序区
            if (R[j + 1] < R[j])
            {                    //交换元素
                R[0] = R[j + 1]; //R[0]不是哨兵，仅作暂存单元
                R[j + 1] = R[j];
                R[j] = R[0];
                exchange = 1; //发生了交换，故将交换标志置为真
            }
        }
        if (!exchange) //本趟排序未发生交换，提前终止算法
            return;
    }
}
```

#### 完整代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 255
int R[MAX];
void Bubble_Sort(int n)
{
    /*R(1..n)是待排序的元素，采用自下向上扫描，对R做冒泡排序*/
    int i, j;
    int exchange; //交换标志
    for (i = 0; i < n; i++)
    {
        exchange = 0; //本趟排序开始，交换标志为假
        for (j = n - 1; j >= i; j--)
        { //对当前无序区R[i..n]自后向上前扫描，并将这之中最小的元素交换到有序区
            if (R[j + 1] < R[j])
            {                    //交换元素
                R[0] = R[j + 1]; //R[0]不是哨兵，仅作暂存单元
                R[j + 1] = R[j];
                R[j] = R[0];
                exchange = 1; //发生了交换，故将交换标志置为真
            }
        }
        if (!exchange) //本趟排序未发生交换，提前终止算法
            return;
    }
}

int main()
{
    int i, n;
    puts("输入要输入的元素的个数：");
    scanf("%d", &n);
    if (n <= 0 || n > MAX)
    {
        printf("n 必须大于0 并且小于 %d.\n", MAX);
        exit(0);
    }
    puts("输入元素：");
    for (i = 1; i <= n; i++)
        scanf("%d", &R[i]);
    puts("\n你输入的数组为：");
    for (i = 1; i <= n; i++)
        printf("%4d", R[i]);
    Bubble_Sort(n);
    puts("\n经过冒泡排序后为:");
    for (i = 1; i <= n; i++)
        printf("%4d", R[i]);
    puts("\n 按任意键退出...");
    getch();
}
```

输出结果：

输入要输入的元素的个数：
5
输入元素：
1 5 3 7 9

你输入的数组为：
   1   5   3   7   9
经过冒泡排序后为:
   1   3   5   7   9
 按任意键退出...