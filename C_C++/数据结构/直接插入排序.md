### 直接插入排序

##### （1）基本思想

假设待排序的记录存放在数组 R[1..n]中。初始时， R[1]自成一个有序区，无序区为 R[2..n]。
从 i=2 起直至 i=n 为止，依次将 R[i]插入当前的有序区 R[1..i-1]中，生成含 n 个记录的有序区。

##### （2）第 i-1 趟直接插入排序

通常将一个记录 R[i](i=2,3,…,n-1)插入到当前的有序区，使得插入后仍保证该区间里的记录
是按关键字有序的操作，称为第 i-1 趟直接插入排序。
排序过程的某一中间时刻， R 被划分成两个子区间 R[1..i-1]（已排好序的有序区）和 R[i..n]
（当前未排序的部分，可称无序区）。
直接插入排序的基本操作是将当前无序区的第 1 个记录 R[i]插入到有序区 R[1..i-1]中适当的
位置上，使 R[1..i]变为新的有序区。因为这种方法每次使有序区增加 1 个记录，通常称增量法。
插入排序与打扑克时整理手上的牌非常类似。摸来的第 1 张牌无需整理，此后每次从桌上的
牌（无序区）中摸最上面的 1 张并插入左手的牌（有序区）中正确的位置上。为了找到这个正确
的位置，需自左向右（或自右向左）将摸来的牌与左手中已有的牌逐一比较。  

#### 一趟直接插入排序

##### （ 1）简单方法

首先在当前有序区 R[1..i-1]中查找 R[i]的正确插入位置 k(1≤k≤i-1)； 然后将 R[k..i-1]中的记
录均后移一个位置，腾出 k 位置上的空间插入 R[i]。
注意：若 R[i]的关键字大于等于 R[1． ． i-1]中所有记录的关键字，则 R[i]就插入原位置。

##### （ 2）改进的方法

这是一种查找比较操作和记录移动操作交替进行的方法。
具体做法：将待插入记录 R[i]的关键字从右向左依次与有序区中记录 R[j](j=i-1,i-2,…,1)的关
键字进行比较：①若 R[j]的关键字大于 R[i]的关键字，则将 R[j]后移一个位置；②若 R[j]的关键字
小于或等于 R[i]的关键字，则查找过程结束， j+1 即为 R[i]的插入位置。
关键字比 R[i]的关键字大的记录均已后移，所以 j+1 的位置已经腾空，只要将 R[i]直接插入
此位置即可完成一趟直接插入排序  

#### 直接插入排序算法

算法描述如下

```c
void Insert_sort(int n)
{ /*对数组R中的记录R[1..n]按递增*/
    int i, j;
    for (i = 2; i <= n; i++) /* 依次插入 R[2]，…， R[n] */
        if (R[i] < R[i - 1])
        { /* 若 R[i]大于等于有序区中所有的 R，则 R[i] 应在原有位置上 */
            R[0] = R[i];
            j = i - 1; /* R[0]是哨兵，且是 R[i]的副本 */
            do
            { /* 从右向左在有序区 R[1． ． i-1]中查找 R[i]的插入位置 */
                R[j + 1] = R[j]; /* 将关键字大于 R[i]的记录后移 */
                j--;
            } while (R[0] < R[j]); /* 当 R[i]≥R[j]时终止 */
            R[j + 1] = R[0];       /* R[i]插入到正确的位置上 */
        }
}
```

#### 完整代码如下：

```c
/*///////////////////////////////////////////////////////////////*/
/*                      直接插入排序                             /*/
/*//////////////////////////////////////////////////////////////*/
#include <stdio.h>
#include <stdlib.h>

#define MAX 255

int R[MAX];

void Insert_sort(int n)
{ /*对数组R中的记录R[1..n]按递增*/
    int i, j;
    for (i = 2; i <= n; i++) /* 依次插入 R[2]，…， R[n] */
        if (R[i] < R[i - 1])
        { /* 若 R[i]大于等于有序区中所有的 R，则 R[i] 应在原有位置上 */
            R[0] = R[i];
            j = i - 1; /* R[0]是哨兵，且是 R[i]的副本 */
            do
            { /* 从右向左在有序区 R[1． ． i-1]中查找 R[i]的插入位置 */
                R[j + 1] = R[j]; /* 将关键字大于 R[i]的记录后移 */
                j--;
            } while (R[0] < R[j]); /* 当 R[i]≥R[j]时终止 */
            R[j + 1] = R[0];       /* R[i]插入到正确的位置上 */
        }
}

int main()
{
    int i, n;
    puts("输入要输入的元素的个数：");
    scanf("%d", &n);
    if (n <= 0 || n > MAX)
    {
        printf("n must more than 0 and less than %d.\n", MAX);
        exit(0);
    }
    puts("输入元素：");
    for (i = 1; i <= n; i++)
        scanf("%d", &R[i]);
    puts("\n你输入的数组为：");
    for (i = 1; i <= n; i++)
        printf("%4d", R[i]);
    Insert_sort(n);
    puts("\n经过插入排序后为:");
    for (i = 1; i <= n; i++)
        printf("%4d", R[i]);
    puts("\n 按任意键退出...");
    getch();
}
```

### 归纳注释

哨兵的作用： 算法中引进的附加记录 R[0]称监视哨或哨兵（ Sentinel）。 哨兵有两个作用： 

① 进行查找（插入位置）循环之前，它保存了 R[i]的副本，使不致于因记录后移而丢失 R[i]的内容；  

② 它的主要作用是在查找循环中“监视”下标变量 j 是否越界。一旦越界（即 j=0），因为 R[0].key
和自己比较，循环判定条件不成立使得查找循环结束，从而避免了在该循环内的每一次均要检测
j 是否越界（即省略了循环判定条件“ j>=1”）。
		实际上，一切为简化边界条件而引入的附加结点（元素）均可称为哨兵。例如单链表中的头结
点实际上是一个哨兵。引入哨兵后可以使得测试查找循环条件的时间减少了一半，所以对于记录数
较大的文件节约的时间就相当可观。对于类似于排序这样使用频率非常高的算法，要尽可能地减少
其运行时间。所以不能把上述算法中的哨兵视为雕虫小技，而应该深刻理解并掌握这种技巧。
		插入算法的时间性能分析：对于具有 n 个记录的文件，要进行 n-1 趟排序。各种状态下的时
间复杂度：初始文件状态为正序、反序和无序（平均）时，时间复杂度分别为 O(n)、 O(n2)和 O(n2)。
算法的空间复杂度分析：算法所需的辅助空间是一个监视哨，辅助空间复杂度 S(n)=O(1)，是
一个就地排序。
		直接插入排序的稳定性：直接插入排序是稳定的排序方法。  
