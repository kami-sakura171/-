### 汉诺塔问题

### 问题描述：

有3个柱子a,b,c，初始时候在a柱子上从上到下、从小到大放了三个盘子1，2，3，要求经过若干次移动后把盘子按照原来顺序放在c柱上，在移动过程中要求尺码小的盘子必须放在尺码大的盘子上边，b柱子作为中转的柱子。后来，拓展到3个柱子，n个盘子的情况。

### 解析

递归策略是一个过程或函数，在其定义或说明中，有直接或间接调用自身的一种方法，这样通常可以把一个大型复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序代码就可描述出解题过程所需的多次重复计算。

一般解法：
（ 1）将 a 柱子上的 n 个盘子从 a→(b)→c，可以用 b 作为过渡盘。
		① a 柱上面的 n–1 个盘子（ 1 号~n–1 号）从 a→(c)→b。
		② 把 a 最下面的最大的那个盘子（第 n 个）从 a→c。
		③ 把 n–1 个（ 1 号~n–1 号）盘子从 b→(a)→c。
（ 2）解决步骤（ 1）中的②，把一个盘从一个柱子搬到另一个柱子，很容易解决。
（ 3）解决步骤（ 1）中的①。
		将 a 柱上的 n–2 个（ 1 号~n–2 号）盘子从 a→( )→c。
		把 a 柱此时最下面的最大的盘子（第 n–1 个）从 a→c。
		把 n–2 个（ 1 号~n–2 号）盘子从 c→( )→b。
（ 4）解决步骤（ 1）中的③。
		将 b 柱上的 n–2 个（ 1 号~n–2 号）盘子从 b→( )→a。
		把 b 柱此时最下面的最大的盘子（第 n–1 个）从 b→c。
		把 n–2 个（ 1 号~n–2 号）盘子从 a→( )→c。
	……
一直到递归的出口的条件——当盘子只有一个的时候。  

### 代码：

```c
/*///////////////////////////////////////////////////////////// /*/
/*                      汉诺塔问题                               /*/
/*//////////////////////////////////////////////////////////////*/
#include <stdio.h>
#include <stdlib.h>
/*     hanoil子程序，实现将n个盘子从a移动到c     */
void hanoil(int n, char a, char b, char c)
{
    if (n == 1) //递归调用的出口,n = 1
        printf("移动第%d号 从 %c 到  %c \n", n, a, c);
    else
    {
        hanoil(n - 1, a, c, b); //递归调用
        printf("移动第%d号 从 %c 到  %c \n", n, a, c);
        hanoil(n - 1, b, a, c);
    }
}

int main()
{
    int n;
    char a = 'A';
    char b = 'B';
    char c = 'C';
    printf("输入盘子的数量：");
    scanf("%d", &n);
    if (n < 0)
    {
        puts("n<1！\n");
        exit(1);
    }
    puts("移动步骤如下:\n");
    hanoil(n, a, b, c);
    puts("\n按任意键退出...");
    getch();
}
```

### 输出结果：

输入盘子的数量：3
移动步骤如下:

移动第1号 从 A 到  C
移动第2号 从 A 到  B
移动第1号 从 C 到  B
移动第3号 从 A 到  C
移动第1号 从 B 到  A
移动第2号 从 B 到  C
移动第1号 从 A 到  C

按任意键退出...

